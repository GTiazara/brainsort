<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>NeuroTri ‚Äî Formes logiques V4</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  .shape-box {
    width: 240px;
    height: 240px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: auto;
  }
</style>
</head>
<body class="bg-gray-50 text-gray-800 p-4">

<h1 class="text-3xl font-bold text-blue-600 text-center mb-3">üß† NeuroTri ‚Äî Formes logiques V4</h1>

<div id="settings" class="max-w-md mx-auto bg-white p-4 rounded-xl shadow space-y-4">

  <div>
    <label class="font-semibold">Type de r√®gle</label>
    <select id="ruleMode" class="w-full border rounded p-2">
      <option value="fill">R√®gle remplissage</option>
      <option value="color">R√®gle couleur</option>
      <option value="shapeColor">R√®gle forme + couleur</option>
      <option value="size">R√®gle taille</option>
      <option value="position">R√®gle position</option>
      <option value="orientation">R√®gle orientation</option>
      <option value="pattern">R√®gle motif</option>
      <option value="sequential">R√®gle s√©quentielle</option>
    </select>
    <div id="ruleDescription" class="text-sm text-gray-700 mt-2 p-2 bg-gray-100 rounded"></div>
  </div>

  <div>
    <label class="font-semibold">Mode Challenge</label>
    <label class="relative inline-flex items-center cursor-pointer float-right">
      <input type="checkbox" id="challengeMode" class="sr-only peer" checked>
      <div class="w-14 h-7 bg-gray-300 rounded-full peer-checked:bg-red-500"></div>
      <div class="absolute left-1 top-1 w-5 h-5 bg-white rounded-full shadow peer-checked:translate-x-7"></div>
    </label>
  </div>

  <div>
    <label class="font-semibold">Nombre de s√©quences</label>
    <input id="sequenceCount" type="number" min="1" max="100" value="10" class="w-full border rounded p-2">
  </div>

  <div>
    <label class="font-semibold">Temps limite par s√©quence (s)</label>
    <input id="timeLimit" type="number" min="0.5" step="0.5" max="30" value="4" class="w-full border rounded p-2">
  </div>

  <button id="startBtn" class="w-full bg-green-600 text-white py-2 rounded-lg">D√©marrer</button>
</div>

<div id="hud" class="hidden max-w-md mx-auto mt-4 flex justify-between">
  <div class="font-semibold">‚è± <span id="timer">0.00</span>s</div>
  <div id="nextBadge" class="hidden bg-yellow-100 px-3 py-1 rounded-full text-yellow-800">
    Attendu : <strong id="nextKey"></strong>
  </div>
</div>

<div id="gameArea" class="hidden max-w-md mx-auto bg-white p-6 mt-4 rounded-xl shadow text-center">
  <div id="shapeArea" class="shape-box"></div>
  <p id="shapeInfo" class="text-sm text-gray-600 mt-2"></p>
  <div class="flex gap-3 justify-center mt-4">
    <button class="px-6 py-3 rounded bg-gray-100 border" id="btnN">N</button>
    <button class="px-6 py-3 rounded bg-gray-100 border" id="btnX">X</button>
  </div>
</div>

<div id="resultCard" class="hidden max-w-md mx-auto mt-6 bg-white p-4 rounded-xl shadow text-center">
  <div id="resultTitle" class="text-2xl font-bold"></div>
  <p id="resultText" class="text-lg mt-2"></p>
  <button id="backBtn" class="mt-4 px-4 py-2 bg-gray-300 rounded">Retour</button>
</div>

<script>
const ruleMode = document.getElementById('ruleMode');
const ruleDescription = document.getElementById('ruleDescription');
const sequenceCount = document.getElementById('sequenceCount');
const timeLimit = document.getElementById('timeLimit');
const challengeMode = document.getElementById('challengeMode');

let expected = 'N';
let remaining = 0;
let rounds = 0;
let timerInterval = null;
let previousShape = null;

// D√©finition des r√®gles
const rules = {
  fill: s => s.fill==='empty'? (s.color==='blue'?'N':'X') : (s.shape==='square'?'N':'X'),
  color: s => s.color==='blue'? (s.shape==='square'?'N':'X') : (s.fill==='empty'?'N':'X'),
  shapeColor: s => s.shape==='square' && s.color==='blue'? 'N' : s.shape==='triangle' && s.color==='orange'? 'N' : 'X',
  size: s => s.size==='large'?'N':'X',
  position: s => s.position==='left'?'N':'X',
  orientation: s => s.orientation==='up'?'N':'X',
  pattern: s => s.pattern==='striped'?'N':'X',
  sequential: (s, prev) => !prev?'N': prev.shape==='square'? (s.shape==='triangle'?'N':'X') : (s.shape==='triangle'?'X':'N')
};

// Description des r√®gles
function updateRuleText(){
  const descriptions = {
    fill: 'VIDE ‚Üí (Bleu=N / Orange=X)<br>REMPLI ‚Üí (Carr√©=N / Triangle=X)',
    color: 'Bleu ‚Üí (Carr√©=N / Triangle=X)<br>Orange ‚Üí (Vide=N / Rempli=X)',
    shapeColor: 'Carr√© BLEU = N<br>Triangle ORANGE = N<br>Autre = X',
    size: 'Grande taille = N<br>Petite taille = X',
    position: 'Gauche = N<br>Centre ou Droite = X',
    orientation: 'Orientation vers le haut = N<br>Autre = X',
    pattern: 'Ray√© = N<br>Uni = X',
    sequential: 'Suivi s√©quentiel : Carr√©‚ÜíTriangle = N'
  };
  ruleDescription.innerHTML = descriptions[ruleMode.value] || '';
}
updateRuleText();
ruleMode.onchange = updateRuleText;

// G√©n√©ration d'une forme al√©atoire
function randomShape(prev = null){
  const shapes = ['square','triangle'];
  const colors = ['blue','orange'];
  const fills = ['filled','empty'];
  const sizes = ['small','large'];
  const positions = ['left','center','right'];
  const orientations = ['up','right','down','left'];
  const patterns = ['solid','striped'];
  return {
    shape: shapes[Math.floor(Math.random()*shapes.length)],
    color: colors[Math.floor(Math.random()*colors.length)],
    fill: fills[Math.floor(Math.random()*fills.length)],
    size: sizes[Math.floor(Math.random()*sizes.length)],
    position: positions[Math.floor(Math.random()*positions.length)],
    orientation: orientations[Math.floor(Math.random()*orientations.length)],
    pattern: patterns[Math.floor(Math.random()*patterns.length)],
    previous: prev
  };
}

// Calcul de la r√©ponse
function computeAnswer(shape){
  const rule = rules[ruleMode.value];
  return ruleMode.value === 'sequential'? rule(shape, previousShape) : rule(shape);
}

// Rendu SVG avec taille, position et orientation
function render(shape){
  previousShape = shape;
  const area = document.getElementById('shapeArea');
  area.innerHTML = '';
  const svgNS = "http://www.w3.org/2000/svg";
  let svg = document.createElementNS(svgNS,"svg");

  // Taille
  let size = shape.size === 'large' ? 150 : 100;
  svg.setAttribute("width", size);
  svg.setAttribute("height", size);

  // Position
  svg.style.marginLeft = shape.position === 'left' ? '0' : shape.position === 'center' ? 'auto' : 'auto';
  svg.style.marginRight = shape.position === 'right' ? '0' : 'auto';

  // Orientation
  let transform = '';
  if(shape.orientation==='up') transform='';
  if(shape.orientation==='right') transform=`rotate(90 ${size/2} ${size/2})`;
  if(shape.orientation==='down') transform=`rotate(180 ${size/2} ${size/2})`;
  if(shape.orientation==='left') transform=`rotate(270 ${size/2} ${size/2})`;

  // Carr√©
  if(shape.shape==='square'){
    let rect = document.createElementNS(svgNS,"rect");
    rect.setAttribute("x",0);
    rect.setAttribute("y",0);
    rect.setAttribute("width", size);
    rect.setAttribute("height", size);
    rect.setAttribute("fill", shape.fill==='filled' ? (shape.color==='blue'?'#2563eb':'#fb923c') : 'transparent');
    rect.setAttribute("stroke", shape.fill==='empty' ? (shape.color==='blue'?'#2563eb':'#fb923c') : 'none');
    rect.setAttribute("stroke-width",6);
    if(transform) rect.setAttribute("transform", transform);
    svg.appendChild(rect);
  }

  // Triangle
  if(shape.shape==='triangle'){
    let tri = document.createElementNS(svgNS,"polygon");
    let scale = size / 150;
    let points = `${75*scale},${0*scale} ${0*scale},${130*scale} ${150*scale},${130*scale}`;
    tri.setAttribute("points", points);
    tri.setAttribute("fill", shape.fill==='filled' ? (shape.color==='blue'?'#2563eb':'#fb923c') : 'transparent');
    tri.setAttribute("stroke", shape.fill==='empty' ? (shape.color==='blue'?'#2563eb':'#fb923c') : 'none');
    tri.setAttribute("stroke-width",6);
    if(transform) tri.setAttribute("transform", transform);
    svg.appendChild(tri);
  }

  area.appendChild(svg);

  document.getElementById('shapeInfo').textContent = 
    `${shape.shape} ¬∑ ${shape.color} ¬∑ ${shape.fill} ¬∑ ${shape.size} ¬∑ ${shape.position} ¬∑ ${shape.orientation} ¬∑ ${shape.pattern}`;
}

// Timer et rounds
function startRound(){
  if(rounds<=0) return endGame(true);
  rounds--;
  const shape = randomShape(previousShape);
  render(shape);
  expected = computeAnswer(shape);
  document.getElementById('nextKey').textContent = expected;

  if(challengeMode.checked){
    remaining = parseFloat(timeLimit.value);
    clearInterval(timerInterval);
    timerInterval = setInterval(()=>{
      remaining -= 0.1;
      document.getElementById('timer').textContent = remaining.toFixed(2);
      if(remaining <=0){
        clearInterval(timerInterval);
        return endGame(false,true);
      }
    },100);
  }
}

function pick(key){
  if(key===expected) startRound();
  else endGame(false,false,expected);
}

document.getElementById('btnN').onclick=()=>pick('N');
document.getElementById('btnX').onclick=()=>pick('X');
document.addEventListener('keydown', e=>{
  if(e.key==='n'||e.key==='N') pick('N');
  if(e.key==='x'||e.key==='X') pick('X');
});

function endGame(success,timeOut=false,correct=null){
  clearInterval(timerInterval);
  document.getElementById('gameArea').classList.add('hidden');
  document.getElementById('resultCard').classList.remove('hidden');
  if(success){
    document.getElementById('resultTitle').textContent='‚úî Termin√©';
    document.getElementById('resultText').textContent='Bravo !';
  } else {
    document.getElementById('resultTitle').textContent='‚ùå Mauvaise r√©ponse';
    document.getElementById('resultText').textContent = 
      timeOut ? 'Temps √©coul√© !' : 'La bonne r√©ponse √©tait : '+correct;
  }
}

document.getElementById('startBtn').onclick=()=>{
  document.getElementById('settings').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  document.getElementById('gameArea').classList.remove('hidden');
  rounds = parseInt(sequenceCount.value);
  startRound();
};

document.getElementById('backBtn').onclick=()=>{
  document.getElementById('settings').classList.remove('hidden');
  document.getElementById('resultCard').classList.add('hidden');
  document.getElementById('gameArea').classList.add('hidden');
};
</script>
</body>
</html>
